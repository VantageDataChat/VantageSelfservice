// Package captcha generates image-based CAPTCHAs with interference stripes.
package captcha

import (
	"bytes"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"image"
	"image/color"
	"image/png"
	"math"
	mrand "math/rand"
	"sync"
	"time"
)

type entry struct {
	answer    string
	expiresAt time.Time
}

var (
	store = make(map[string]entry)
	mu    sync.Mutex
)

// Response holds the captcha ID and base64-encoded PNG image.
type Response struct {
	ID    string `json:"id"`
	Image string `json:"image"` // data:image/png;base64,...
}

// chars used in captcha text (no ambiguous chars like 0/O, 1/l/I)
const chars = "23456789ABCDEFGHJKLMNPQRSTUVWXYZ"

// Generate creates a new image captcha and returns its ID + base64 PNG.
func Generate() *Response {
	mu.Lock()
	defer mu.Unlock()

	// Clean expired
	now := time.Now()
	for k, v := range store {
		if now.After(v.expiresAt) {
			delete(store, k)
		}
	}

	// Generate random 4-char text
	text := make([]byte, 4)
	for i := range text {
		text[i] = chars[mrand.Intn(len(chars))]
	}
	answer := string(text)

	id := generateCaptchaID()
	store[id] = entry{
		answer:    answer,
		expiresAt: now.Add(5 * time.Minute),
	}

	img := renderCaptcha(answer, 240, 80)

	var buf bytes.Buffer
	png.Encode(&buf, img)
	b64 := base64.StdEncoding.EncodeToString(buf.Bytes())

	return &Response{
		ID:    id,
		Image: "data:image/png;base64," + b64,
	}
}

// Validate checks the answer (case-insensitive) and consumes the captcha.
func Validate(id, answer string) bool {
	mu.Lock()
	defer mu.Unlock()

	e, ok := store[id]
	if !ok {
		return false
	}
	delete(store, id)
	if time.Now().After(e.expiresAt) {
		return false
	}
	if len(answer) != len(e.answer) {
		return false
	}
	for i := 0; i < len(answer); i++ {
		a, b := answer[i], e.answer[i]
		if a >= 'a' && a <= 'z' {
			a -= 32
		}
		if b >= 'a' && b <= 'z' {
			b -= 32
		}
		if a != b {
			return false
		}
	}
	return true
}

// renderCaptcha draws the text with interference stripes onto an image.
func renderCaptcha(text string, width, height int) *image.RGBA {
	img := image.NewRGBA(image.Rect(0, 0, width, height))

	// Background: light random color
	bgR := uint8(230 + mrand.Intn(25))
	bgG := uint8(230 + mrand.Intn(25))
	bgB := uint8(230 + mrand.Intn(25))
	for y := 0; y < height; y++ {
		for x := 0; x < width; x++ {
			img.Set(x, y, color.RGBA{bgR, bgG, bgB, 255})
		}
	}

	// Draw interference lines
	for i := 0; i < 6; i++ {
		lineColor := color.RGBA{
			uint8(mrand.Intn(200)),
			uint8(mrand.Intn(200)),
			uint8(mrand.Intn(200)),
			255,
		}
		drawLine(img, mrand.Intn(width), mrand.Intn(height), mrand.Intn(width), mrand.Intn(height), lineColor, 2)
	}

	// Draw noise dots
	for i := 0; i < 100; i++ {
		img.Set(mrand.Intn(width), mrand.Intn(height), color.RGBA{
			uint8(mrand.Intn(255)), uint8(mrand.Intn(255)), uint8(mrand.Intn(255)), 255,
		})
	}

	// Draw each character with scale=3 (each glyph pixel becomes 3x3)
	scale := 3
	glyphW := 12 * scale // rendered char width
	totalW := glyphW * len(text)
	startX := (width - totalW) / 2

	for i, ch := range text {
		cx := startX + i*glyphW + glyphW/2
		cy := height/2 + mrand.Intn(8) - 4
		charColor := color.RGBA{
			uint8(mrand.Intn(80)),
			uint8(mrand.Intn(80)),
			uint8(mrand.Intn(80)),
			255,
		}
		drawCharHiRes(img, cx, cy, byte(ch), charColor, scale)
	}

	// Draw more interference lines on top
	for i := 0; i < 3; i++ {
		lineColor := color.RGBA{
			uint8(100 + mrand.Intn(155)),
			uint8(100 + mrand.Intn(155)),
			uint8(100 + mrand.Intn(155)),
			180,
		}
		drawLine(img, 0, mrand.Intn(height), width, mrand.Intn(height), lineColor, 1)
	}

	return img
}

// drawCharHiRes renders a character using a 12x16 hi-res bitmap font, scaled by the given factor.
func drawCharHiRes(img *image.RGBA, cx, cy int, ch byte, c color.RGBA, scale int) {
	glyph := getGlyphHiRes(ch)
	if glyph == nil {
		return
	}
	rows := len(glyph)
	cols := 12
	startX := cx - (cols*scale)/2
	startY := cy - (rows*scale)/2
	skew := float64(mrand.Intn(5)-2) * 0.08

	for row := 0; row < rows; row++ {
		bits := glyph[row]
		for col := 0; col < cols; col++ {
			if bits&(1<<uint(cols-1-col)) != 0 {
				px := startX + col*scale + int(math.Round(float64(row)*skew))
				py := startY + row*scale
				for dy := 0; dy < scale; dy++ {
					for dx := 0; dx < scale; dx++ {
						img.Set(px+dx, py+dy, c)
					}
				}
			}
		}
	}
}

// drawLine draws a line with given thickness.
func drawLine(img *image.RGBA, x1, y1, x2, y2 int, c color.RGBA, thickness int) {
	dx := x2 - x1
	dy := y2 - y1
	steps := abs(dx)
	if abs(dy) > steps {
		steps = abs(dy)
	}
	if steps == 0 {
		return
	}
	xInc := float64(dx) / float64(steps)
	yInc := float64(dy) / float64(steps)
	x := float64(x1)
	y := float64(y1)
	half := thickness / 2
	for i := 0; i <= steps; i++ {
		for t := -half; t <= half; t++ {
			img.Set(int(x), int(y)+t, c)
			img.Set(int(x)+t, int(y), c)
		}
		x += xInc
		y += yInc
	}
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

// generateCaptchaID creates a cryptographically random captcha ID.
func generateCaptchaID() string {
	b := make([]byte, 12)
	if _, err := rand.Read(b); err != nil {
		return fmt.Sprintf("cap_%d", time.Now().UnixNano())
	}
	return fmt.Sprintf("cap_%x", b)
}

// getGlyphHiRes returns a 12-wide x 16-tall bitmap for the given character.
// Each uint16 represents one row; the top 12 bits are used.
func getGlyphHiRes(ch byte) []uint16 {
	glyphs := map[byte][]uint16{
		'2': {
			0x0000, 0x1F00, 0x3180, 0x2080, 0x0080, 0x0100, 0x0200, 0x0400,
			0x0800, 0x1000, 0x2000, 0x3F80, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'3': {
			0x0000, 0x1F00, 0x3180, 0x0080, 0x0080, 0x0700, 0x0080, 0x0080,
			0x0080, 0x0080, 0x3180, 0x1F00, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'4': {
			0x0000, 0x0100, 0x0300, 0x0500, 0x0900, 0x1100, 0x2100, 0x3F80,
			0x0100, 0x0100, 0x0100, 0x0100, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'5': {
			0x0000, 0x3F80, 0x2000, 0x2000, 0x3F00, 0x0180, 0x0080, 0x0080,
			0x0080, 0x0080, 0x3180, 0x1F00, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'6': {
			0x0000, 0x0F00, 0x1800, 0x2000, 0x2000, 0x3F00, 0x3180, 0x2080,
			0x2080, 0x2080, 0x3180, 0x1F00, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'7': {
			0x0000, 0x3F80, 0x0080, 0x0100, 0x0100, 0x0200, 0x0200, 0x0400,
			0x0400, 0x0800, 0x0800, 0x0800, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'8': {
			0x0000, 0x1F00, 0x3180, 0x2080, 0x3180, 0x1F00, 0x3180, 0x2080,
			0x2080, 0x2080, 0x3180, 0x1F00, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'9': {
			0x0000, 0x1F00, 0x3180, 0x2080, 0x2080, 0x3180, 0x1F80, 0x0080,
			0x0080, 0x0080, 0x0300, 0x1E00, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'A': {
			0x0000, 0x0400, 0x0A00, 0x0A00, 0x1100, 0x1100, 0x2080, 0x2080,
			0x3F80, 0x2080, 0x2080, 0x2080, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'B': {
			0x0000, 0x3F00, 0x2080, 0x2080, 0x2080, 0x3F00, 0x2080, 0x2080,
			0x2080, 0x2080, 0x2080, 0x3F00, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'C': {
			0x0000, 0x1F00, 0x3180, 0x2080, 0x2000, 0x2000, 0x2000, 0x2000,
			0x2000, 0x2080, 0x3180, 0x1F00, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'D': {
			0x0000, 0x3E00, 0x2100, 0x2080, 0x2080, 0x2080, 0x2080, 0x2080,
			0x2080, 0x2080, 0x2100, 0x3E00, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'E': {
			0x0000, 0x3F80, 0x2000, 0x2000, 0x2000, 0x3F00, 0x2000, 0x2000,
			0x2000, 0x2000, 0x2000, 0x3F80, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'F': {
			0x0000, 0x3F80, 0x2000, 0x2000, 0x2000, 0x3F00, 0x2000, 0x2000,
			0x2000, 0x2000, 0x2000, 0x2000, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'G': {
			0x0000, 0x1F00, 0x3180, 0x2080, 0x2000, 0x2000, 0x2380, 0x2080,
			0x2080, 0x2080, 0x3180, 0x1F00, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'H': {
			0x0000, 0x2080, 0x2080, 0x2080, 0x2080, 0x3F80, 0x2080, 0x2080,
			0x2080, 0x2080, 0x2080, 0x2080, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'J': {
			0x0000, 0x0380, 0x0080, 0x0080, 0x0080, 0x0080, 0x0080, 0x0080,
			0x0080, 0x2080, 0x3180, 0x1F00, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'K': {
			0x0000, 0x2080, 0x2100, 0x2200, 0x2400, 0x2800, 0x3000, 0x2800,
			0x2400, 0x2200, 0x2100, 0x2080, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'L': {
			0x0000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000, 0x2000,
			0x2000, 0x2000, 0x2000, 0x3F80, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'M': {
			0x0000, 0x2080, 0x3180, 0x3180, 0x2A80, 0x2A80, 0x2480, 0x2080,
			0x2080, 0x2080, 0x2080, 0x2080, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'N': {
			0x0000, 0x2080, 0x3080, 0x3080, 0x2880, 0x2880, 0x2480, 0x2480,
			0x2280, 0x2280, 0x2180, 0x2080, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'P': {
			0x0000, 0x3F00, 0x2080, 0x2080, 0x2080, 0x2080, 0x3F00, 0x2000,
			0x2000, 0x2000, 0x2000, 0x2000, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'Q': {
			0x0000, 0x1F00, 0x3180, 0x2080, 0x2080, 0x2080, 0x2080, 0x2080,
			0x2480, 0x2280, 0x3100, 0x1E80, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'R': {
			0x0000, 0x3F00, 0x2080, 0x2080, 0x2080, 0x2080, 0x3F00, 0x2200,
			0x2100, 0x2100, 0x2080, 0x2080, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'S': {
			0x0000, 0x1F00, 0x3180, 0x2000, 0x2000, 0x1800, 0x0700, 0x0080,
			0x0080, 0x2080, 0x3180, 0x1F00, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'T': {
			0x0000, 0x3F80, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400, 0x0400,
			0x0400, 0x0400, 0x0400, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'U': {
			0x0000, 0x2080, 0x2080, 0x2080, 0x2080, 0x2080, 0x2080, 0x2080,
			0x2080, 0x2080, 0x3180, 0x1F00, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'V': {
			0x0000, 0x2080, 0x2080, 0x2080, 0x1100, 0x1100, 0x1100, 0x0A00,
			0x0A00, 0x0A00, 0x0400, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'W': {
			0x0000, 0x2080, 0x2080, 0x2080, 0x2080, 0x2480, 0x2480, 0x2A80,
			0x2A80, 0x3180, 0x3180, 0x2080, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'X': {
			0x0000, 0x2080, 0x2080, 0x1100, 0x0A00, 0x0400, 0x0400, 0x0A00,
			0x1100, 0x2080, 0x2080, 0x2080, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'Y': {
			0x0000, 0x2080, 0x2080, 0x1100, 0x0A00, 0x0400, 0x0400, 0x0400,
			0x0400, 0x0400, 0x0400, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000,
		},
		'Z': {
			0x0000, 0x3F80, 0x0080, 0x0100, 0x0200, 0x0400, 0x0800, 0x1000,
			0x2000, 0x2000, 0x2000, 0x3F80, 0x0000, 0x0000, 0x0000, 0x0000,
		},
	}
	return glyphs[ch]
}
